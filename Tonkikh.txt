Пояснительная записка

Проблема с заполненностью последнего бита была решена добавлением 3 битов в самое начало файла - они сохраняют информацию о количестве недостающих бит в последнем байте. Поскольку число недостающих до байта бит может лежать в пределах от 0 до 7, 3 бит на эту информацию вполне достаточно.

После этих 3 бит лежит 1 байт с количеством видов различных байт в оригинальном файле len_dict. Если число было равно 256, этот байт заполняется нулями. 

Хранение словаря производится следующей последовательностью: словарь вида {188: bitarray('00'), 139: bitarray('0100'), ...} переводится по следующим правилам: для каждой пары ключ-значение, ключ заносится в отдельный байт, затем в следующий байт заносится число бит, которые занимает значение (для bitarray('00') - 2, для bitarray('0100') - 4 и т.д.), после чего считывается ровно то количество бит, что было указано в этом втором байте. Считанные биты и являются шифр-кодом, а данная итерация проводится по количеству len_dict.


В основном картинки, поскольку в них довольно равномерно встречаются все биты и нельзя выделить наиболее частые или редкие биты, сжимаются плохо. Аналогичная ситуация с pdf-файлами. Аналогично сжимаются видеофайлы.
Текст программы в Jupiter notebook сжимается в ~5 раз, что показывает хороший результат для файлов с неравномерным распределением частоты встречаемости байт.

Сжатие происходит довольно быстро, однако извлечение занимает в несколько раз больше времени, поскольку недетерминирована длина шифр-кода для каждого байта. Тем не менее сжимается файл размером 65 Мб за 10 секунд, а извлекается за 81 секунду, что является не очень плохим результатом.

